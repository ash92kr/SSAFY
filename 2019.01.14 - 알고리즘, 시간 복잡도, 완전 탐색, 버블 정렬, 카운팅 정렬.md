# 2019.01.14



Inter-median > Adanced > Professional > Expert

IM : 다중 반복문을 자유자재로 사용할 수 있으면 된다(2/3중)

AD : 완전검색(모든 경우의 수 파악) - 재귀함수, DP(Dynamic Programming - 동적 계획법)

탐욕적 방법 X

PRO : 함수의 구조만 주고 함수를 만들어야 한다(7~8장), 알고리즘은 거의 없다

EXPERT : 코드의 품질(시간 최적화)을 본다



`swexpertacademy.com`  → 여기 가입해서 앞으로 문제풀 것

A형 : IM / B형 : AD / C형 : PRO



매일 숙제 이후 그 다음날 발표 - 매주 월, 화요일 수업 및 3월 1/2주 4월 1/2주 전 요일 수업

틀려도 좋으니 자기 스스로 할 것 -> 3/15일 시험



* 오리엔테이션

인터프리터 언어 : 한 줄씩 언어를 실행 -> 보기에 편하나 속도가 느리다

컴파일러 언어 : 입력한 언어를 한번에 실행



* 언어 역사

ALGOL - B - C - Java / C++ - C# - python

데니스 리치의 C언어 : 유닉스 운영체제를 위한 언어로 등장(전문가용)

Java : 본래 Oak였다가 자바산 커피를 마심(SUN - Oracle), 플랫폼 Independent(JRE와 JVM이 있으면 어떤 운영체제든 구동된다)

C++

C# : # = ++++, 자바와 C++의 영향을 모두 받음(마이크로소프트 회사의 대항마)

안드로이드 : 리눅스 커널 위에 안드로이드 프레임워크가 올라감, 자바로 만들어진 것(A, B, C, D 등으로 버전이 올라감)

AP : 스마트폰에 들어가는 CPU

object-C : 애플에서 만든 언어

파이썬 : 라이브러리를 가져다 쓴다



알고리즘 입장에서는 언어는 수단이자 도구에 불과하다 -> 자료구조를 알아야 한다



* 파이참 설치 - 디버깅에 굉장히 용이

https://www.jetbrains.com/ 에서 Tools-pycharm 선택 - community 버전으로 다운로드

![default](https://user-images.githubusercontent.com/43332543/51218428-be859300-196f-11e9-9bc6-bbea55c53254.PNG)

이렇게 체크하고 설치할 것 - creative new project - 폴더에서 우측 마우스 눌러 New - .py 선택

처음에 할 때는 Run - Run...을 선택한 다음부터는 Run '파일명' 선택



앨런 튜링(이미테이션 게임)과 어거스터 에이다 킹(최초 프로그래머)



아직까지도 정렬을 연구하고 있는 컴퓨터 공학

선택 정렬, 버블 정렬, 삽입 정렬 3가지가 가장 시간이 오래 걸린다 -> 쉬울수록 시간이 오래 걸림

카운팅 정렬 : 숫자로 되어 있는 데이터 정렬에 빠름(문자는 불가)



* 알고리즘 : 문제를 해결하기 위한 유한한 절차나 방법 <- 알콰리즈미(수학자)에서 유래

좋은 알고리즘의 기준 : 정확성, 작업량(적게), 메모리 사용량, 단순성, 최적성(개선 여지X)

알고리즘의 성능 분석 필요 - 검증없이 만들면 greedy 알고리즘이 된다



문제를 풀기 위해 먼저 스케치를 해야 한다 -> 문제가 의도하는 것이 무엇인지 적어야 한다

요구사항 분석 -> 설계(연필로 적기) -> 코딩 -> 유지 보수

설계를 할 줄 알아야 개발자이다 = 알고리즘은 설계에 해당



슈더코드 : 내가 어떻게 코드를 짤지 나만 알아볼 수 있게 만드는 것

어떤 문제를 푸는데는 다양한 방법이 있다



* 시간 복잡도 : 알고리즘의 실제로 걸리는 시간 측정

```python
for i in range(1, n+1):
	sum = sum + i   # n번 반복해야 한다
	
return n*(n+1)//2
```



빅오 표기법 : 시간 복잡도 함수 중에서 가장 큰 영향을 주는 최고차항만 표시(계수와 상수항은 제거)

```python
ex) O(3n + 2) = O(3n) = O(n)  /  O(5) = O(1)
```



```python
O(logn)   # log 1024 = log2 2^10 = 10   # 이진탐색
O(n)   # for문을 통해 탐색하는 순차탐색(처음부터 끝까지 재수없게 탐색)
O(nlogn)   # Quick 정렬, Merge 정렬, heap 정렬
O(n^2)   # 선택 정렬, Bubble 정렬, 삽입 정렬  -> for문이 2개이다
O(n^3)   # 모든쌍 최단경로 알고리즘  ex) 서울에서 부산까지 가는 최단경로 찾기(다익스트라 알고리즘)

O(2^n)   # 부분집합   ex) 어떤 집합의 모든 부분집합 구하기
O(n!)   # TSP(여행자 문제) - 출발지에서 도착지까지 모두 둘러본 다음, 다시 출발지로 돌아가는 최단거리 찾기 = 순열이 가장 많이 시간이 오래 걸린다
```



n^3까지 P문제(풀 수 있는 문제)

2^n부터 NP문제(풀기에 어려운 문제-비결정적론 다항 시간) = N이 지나치게 커지면 풀 수 없다

그래서 NP 문제는 근사한 정답을 구한다 = 최적은 아니지만 어쨌든 성능은 구할 수 있다



다시 말하지만 컴퓨터가 아니라 알고리즘이 중요하다





* 배열 = 리스트

어떤 변수 안에 값을 대입한다

그런데 변수가 지나치게 많아질 경우 배열을 생성한다

```python
a = [0] * 100
# 각 상자에 인덱스를 붙인다  0 ~ 99
```

각 상자에 있는 값을 가져오려면 for문을 사용하면 된다 -> 확장해서 중첩 for문



배열이 필요한 이유 : 여러 변수가 필요할 때, 다른 변수명으로 데이터에 접근하면 비효율적(배열을 사용하면 for문을 사용해서 접근하면 된다)

1차원 배열 : 변수에 처음 값을 할당할 때 생성    `배열명 = list()` or `배열명 = []`

1차원 배열 접근 : `배열명[인덱스 번호]`



모든 상자에 대한 값을 구해야 하는가? for문이 몇 개 필요한가? -> 모든 상자에서 나올 수 있는 최대값을 구한다

```python
data = [7, 4, 2, 0, 0, 6, 0, 7, 0]
result = 0
maxHeight = 0

for i in range(len(data)):
	maxHeight = len(data) - (i+1)   # i행의 최대 낙차 값(그 이후 모든 행 검사)
	for j in range(i+1, len(data), 1)   # 2번째 행과 비교
		if data[i] <= data[j]:   # 아래 행이 i행보다 상자가 많으면 최대낙차값을 1감소
			maxHeight -= 1
	if result < maxHeight:
		result = maxHeight
print(result)
```



복원 추출 - 모든 경우의 수를 구해서 검색하는 완전 검색(순열 방식)

<-> 한 방에 해결하는 것을 greedy 방식(모든 경우에 증명이 되었는가?)

완전 검색 : for문 / 재귀함수를 사용해서 풀 수 있다 -> 모든 경우의 수의 나열(brute-force, generate-and-test) = 무식한 방법

따라서 평가에서는 완전 검색부터 접근해서 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘으로 풀어보는 것이 바람직하다(ex)10 정도의 수열)



재귀 함수 = 백 트래킹 -> 해당하지 않는 경우는 삭제하기(굳이 돌릴 필요 없음)

ex) 6개의 숫자로 만들 수 있는 숫자 나열(중복 포함) -> 정렬한 다음, 앞 3자리와 뒤 3자리를 테스트



순열 구하기 3가지 방법 - for문 / 재귀함수  `주의 : 아래 코드는 에러 발생함`

ex) {1, 2, 3} -> 3개의 for문에서 각 for문은 3번 돈다 -> 또한 각 경우마다 if문을 써서 분기

```python
for i in range(1, 4):
	for j in range(1, 4):
		if j != i:
			for k in range(1, 4):
				if k != i and k != j:
					print(i, j, k)
```



```python
def baby_jin(data):
    for i1 in range(6):   # 6이라고 써도 상관은 없다(해당 data 하에서는)
        for i2 in range(6):
            if i2 != i1:
                for i3 in range(6):
                    if i3 != i1 and i3 != i2:
                        for i4 in range(6):
                            if i4 != i1 and i4 != i2 and i4 != i3:
                                for i5 in range(6):
                                    if i5 != i1 and i5 != i2 and i5 != i3 and i5 != i4:
                                        for i6 in range(6):   # 모든 경우의 수 나열
                                            if i6 != i1 and i6 != i2 and i6 != i3 and i6 != i4 and i6 != i5:
                                                chk = 0
                                                print(data[i1], data[i2], data[i3], data[i4], data[i5], data[i6])
                                                if data[i1] == data[i2] and data[i1] == data[i3]:  # data에 있는 값 출력
                                                    chk += 1
                                                if data[i4] == data[i5] and data[i4] == data[i6]:
                                                    chk += 1
                                                if data[i1] + 1 == data[i2] and data[i2] + 1 == data[i3]:
                                                    chk += 1
                                                if data[i4] + 1 == data[i5] and data[i5] + 1 == data[i6]:
                                                    chk += 1
                                                if chk == 2:   # 앞줄 따로 뒷줄따로
                                                    return


data = [6, 6, 7, 7, 6, 7]

if baby_jin(data):
    print("Baby Jin")
else:
    print("Not Baby Jin")
```



* 탐욕 알고리즘 : 최적해를 구하는데 사용되는 근시안 방법

그 순간에 최적이라고 생각되는 것을 선택해나가는 방식으로 진행하므로 해답이 최적이라는 보장이 없다 = 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 greedy 접근이 된다

ex) 거스름돈 줄이기 - 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소로 주기

(1) 해 선택 - 단위가 큰 동전으로만 거스롬돈을 만들면 개수가 줄어든다

(2) 실행 가능성 검사 - 내가 돌려주어야 할 돈이 거스름돈을 초과하는지 확인해 초과하면 마지막에 추가한 동전을 거스름돈에서 빼고 한 단계 작은 단위의 동전 추가

(3) 해 검사 - 거슬러 주어야 할 돈을 확인해 실제로 주어야 할 액수와 모자라면 거스름돈에 추가할 동전을 고른다



6개의 숫자는 6자리의 정수값 -> 배열의 각 원소를 체크해 baby-gin 여부를 판단한다 -> run이 존재하면 run 데이터 삭제 + triplet이 존재하면 triplet 데이터 삭제

```python
num = 123456
c = [0] * 12  # 6자리 수에서 각 자리수를 추출해 개수를 누적할 리스트

for i in range(6):  # num이 양수일 때만 하면 된다
    c[num % 10] += 1  # num의 나머지를 c리스트의 일치하는 인덱스 칸에 +1한다
    num //= 10  # 몫 연산자(num = num // 10) -> 단위를 한번 줄임(1000 -> 100 -> 10)

# print(c)   # 입력이 제대로 되었는지 확인

i = 0
tri = run = 0

while i < 10:
    if c[i] >= 3:  # triplete 조사 부분(해당 인덱스 부분에 3개 이상 숫자가 존재?)
        c[i] -= 3  # 그 칸의 숫자 3 빼기
        tri += 1
        continue  # triplete가 2번일 경우 1개의 숫자에 6이 표시되므로 같은 인덱스를 한번 더 돌아야 한다

    if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1:
        c[i] -= 1
        c[i+1] -= 1
        c[i+2] -= 1  # c[9]일 경우 c[11]에 해당하므로 리스트 항목을 12개 만듦
        run += 1
        continue  # run이 2번일 경우 3개의 숫자에 2가 표시되므로 같은 인덱스를 한번  더 돌아야 한다
    i += 1

if run + tri == 2:
    print("Baby Gin")
else:
    print("Lose")
```



192.168.212.51

student

ssafy0102



* 정렬

버블 / 선택 / 삽입 = n^2  ↔  퀵 정렬 = n * log n

(1) 버블 정렬 : 인접한 2개의 원소를 비교해 서로 교환하는 방식(인접한 원소부터 계속 자리를 교환하면서 마지막까지 이동 = 1단계를 끝나면 그 단계에서 가장 큰 원소가 마지막 자리로 정렬됨)

(2) 선택 정렬 : 가장 작은 것을 찾아서 위치에 맞게 두기

(3) 삽입 정렬 : 모든 요소를 앞에서 이미 정렬된 배열과 비교해 위치에 맞게 삽입



* 버블 정렬 : 인접한 원소끼리 비교해서 교환하는 방식(큰 값을 뒤로 미룸)

1단계가 지날 때마다 비교해야 할 원소가 1개 줄어든다

```python
for i in range(len(a)-1, 0, -1):   # i = path(단계) -> n-1 ~ 0(4, 3, 2, 1 = 4번)
	for j in range(0, i):    # 0 ~ n-1(0~3, 0~2, 0~1, 0 = 4, 3, 2, 1 = 4번)
		if a[j] > a[j+1]:
			a[j], a[j+1] = a[j+1], a[j]    # 앞의 것이 크면 swap

# 나중에는 .sort()나 .reverse())를 사용하면 된다
            
# 참고 c와 java에서의 swap
t = a[i]
a[i] = a[i+1]
a[i+1] = t

# 시간 복잡도 O(N^2)
```

- 별 찍는 연습하기



main / stack / heap

-> 일반 변수는 stack 영역에서 처리를 하고 와도 main에 있는 변수의 값이 바뀌지 않지만,
리스트는 stack 영역의 (함수) 처리가 main 영역에 있는 리스트에도 영향을 끼친다

일반 변수 = call by value,  리스트 = call by reference

그 이유는 일반 변수는 main에 만들어지지만, 리스트는 heap에 만들어지기 때문이다

HDD에 있는 저장 공간 -> RAM에 올려야 연산 가능 -> CPU가 연산 실시



리스트는 크기 때문에 원본을 그대로 가져오지 못하고 주소를 복사, 일반 변수들은 원본을 복사해서 그대로 가져온다



(2) 카운팅 정렬 : 집합에 각 항목이 몇 개씩 있는지 세서 선형 시간에 정렬하는 알고리즘

인덱스를 넣을 집합을 만들어야 한다(counts[i]의 발생 횟수)
정수/정수로 표현할 수 있는 자료에 대해서만 적용 가능(인덱스를 넣어야 한다)
인덱스는 N+1개를 만든다(집합 내 가장 큰 정수를 알아야 한다)

시간복잡도 : O(n+k) -> 리스트 길이 + 정수 최대값(+1)



count 배열에 각 원소의 발생 횟수를 저장한다 -> count[i]까지의 발생 횟수를 누적해서 작성한다

-> 가장 마지막 원소의 인덱스와 counts의 발생횟수를 연동해서 TEMP 에 정렬한다(counts의 인덱스는 감소시킨다)

-> TEMP의 업데이트를 완료하고 정렬 작업 종료 = 원본을 건드리지 않는다

```python
def Counting_Sort(A, B, k)
	A = [ ]    # 입력 배열(range 1~k)
	B = [ ]    # 정렬된 배열
	C = [ ]    # 카운트를 넣을 배열
	
C = [0] * k+1   # 최대값을 구한다

for i in range(0, len(B)):   # count배열에 값 넣기
	C[A[i]] += 1
	
for i in range(1, len(C)):  # count배열 값 누적하기(0은 포함하지 않는다!!!)
	C[i] += C[i-1]
	
for i in range(len(B)-1, -1, -1):
	B[C[A[i]]-1] = A[i] 
	C[A[i]] -= -1   # 입력 배열에 해당하는 값을 카운트 배열의 원소에서 1씩 제거한다
```

* 파이참 - Run - Debug를 눌러 화살표 아래 버튼 누르면 함수 안으로 들어가거나 그 함수를 지날 경우의 값을 보여준다
* 줄 왼쪽의 빨간 버튼을 누르면 거기까지만 실행하고 멈춘다



* 정리

알고리즘 : 문제를 해결하기 위한 유한한 절차나 단계

배열 = 리스트

완전검색 - 우선은 for문만 사용함

그리디 알고리즘 - 머리속에 떠오르는 것을 검증없이 만든 것

버블 정렬

카운팅 정렬



* 자율학습 - 조망권 구하기(양 옆으로 2칸 이상 인접 건물이 없는 칸의 개수를 구해야 한다)

우선은 데이터를 입력받는 방법부터 고민하기

```python
import sys

sys.stdin = open("view_input.txt")     # 표준 입력 - 제출시에는 주석처리

T = 10   # test case

for tc in range(T):
    count = 0   # 정답의 개수
    N = int(input())   # 각 테스트셋의 건물 개수
    data = list(map(int, input().split()))   # 한 줄을 문자열로 받음 -> 숫자로 바꾸고 공백으로 쪼개서 리스트에 넣음

#   K, P = map(int, input().split())  # 만약 2개를 받는 경우

    for i in range(2, len(data)-2):
        if data[i] > data[i+1] and data[i] > data[i+2] and data[i] > data[i-1] and data[i] > data[i-2]:
            count += min(data[i]-data[i-1], data[i]-data[i-2], data[i]-data[i+1], data[i]-data[i+2])

    print("#{} {}".format(tc+1, count))
```

