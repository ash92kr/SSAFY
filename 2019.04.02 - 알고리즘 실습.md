# 2019.04.02





### 1. 복습

그래프 - n대n의 관계



그래프 표현 - 인접 행렬 / 인접 리스트(kruskal을 사용할 때 사용)



그래프 탐색 - 그래프에 있는 모든 자료를 빠짐없이 탐색



상호배타 집합 - make-set() : 부모에 자기 자신을 넣음, find-set() : 부모를 따라 대표자 찾기(부모=자기 자신일 때 return, 그렇지 않으면 재귀를 통해 p값을 전함), union() : x와 y의 대표자를 찾아 y의 부모를 x로 지정



최소 신장트리 - Prim / Kruskal

```
Prim은 임의의 정점을 선택해 시작 -> 선택한 정점과 인접하는 정점들 중 최소 가중치 간선을 선택한다
# Prim은 송유관, 다익스트라는 네비게이션에서 사용
# 정점이 짧은 것부터 순차적으로 이동 = 그리디 알고리즘
# 어디에서 왔는지(부모), 가중치가 얼마인지 저장하는 배열이 필요하다


def PRIM(G, r):
	For u in G.V:
		u.key = 987654321   # 가중치 초기값
		u.p = null  # 자기 자신을 넣어도 됨
```



```
그림에 대한 Prim 알고리즘 순서(정점 순서 상관없음)
서울 - 천안 - 논산 - 대전 - 대구 - 원주 - 부산 - 포항 - 광주 - 강릉의 순으로 이동
```



```
그림에 대한 Kruskal 알고리즘 순서
# 가중치가 필요없다
# 가장 짧은 가중치부터 시작해 사이클이 생기지 않는 가중치(간선)만 선택한다
3 - 4 - 9 - 10 - 12 - 13 - 21로 V-1개 될 때까지 선택
```



```
그림에 대한 Dijkstra 알고리즘 순서
# 정점의 초기화 가중치는 모두 무한대
# 정점을 이동하면서 가중치를 전부 합산한다 -> 전체를 고려하면서 간선이 바뀔 수 있다 -> 이미 계산한 가중치도 최소값일 경우, 바뀔 수 있다
서울 - 천안(12) - 논산(16) - 대전(19) - 원주(15) - 대구(22) - 부산(31) - 광주(29) - 포함(36) - 강릉(36)
서울 - 원주 - 대구 - 부산
```



```
# 프로이드 알고리즘
# 직접 가는 것이 더 빠른지 아니면 경우해서 가는 게 더 빠른지 계산
```



* 문제 복습(파일 참고)





데이터의 본질 - 어떤 데이터를 가지고 고객을 유인할 것인가?

사회과학자료원, 공공 빅데이터 -> 개인정보보호법 + 문화적 특수성

