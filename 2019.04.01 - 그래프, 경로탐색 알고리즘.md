# 2019.04.01





### 1. 복습

순열과 조합 - 가지치기를 해야 10초 안에 나온다



AD도 쉬운 것부터 먼저 풀 것

문제에서 제시된 대로 풀 것

```
for i1 in range(4):  # 굳이 조합을 넣을 필요가 없다
	for i2 in range(5):
		for i3 in range(6):
			temp = abs() + () + ()
```



완전검색(재귀) + 가지치기 = 순열 / 조합 / 부분집합



* 최소합

```
# 항상 출발이 0, 0이므로 출발점부터 sum을 쥐고 가져간다
# 델타 검색을 이용해 for문을 돌린다
# N-1, N-1 지점에 도착하면 종료한다
# 벽처리시 0보다 작은 경우는 고려하지 않아도 된다

# 아래나 오른쪽으로 이동 가능한지 확인
```



* 전기카트 - TSP

```
# 순열로 풀면 된다 -> 0 - {1, 2, 3} - 0 으로 돌아와야 한다
# 행렬로 거리를 받고, 첫 번째는 제외해도 된다

# 첫 번째는 사용하지 않으므로 [0] * [N] + [0]으로 변형하고 순열을 돌림
```



* 컨테이너 운반

```
# 완전 검색으로 풀어야 한다
# w.sort(reverse=True)   # 내림차순
# 그리디는 IM 수준에 해당한다
```



* 화물도크

```
# 강의실 배정과 동일한 문제
# 시작-종료로 데이터를 받음
```



* 베이비진 게임

```
# 숫자에 대한 카운팅 - 카드의 값을 인덱스로 놓고 계산
```



* 최대상금

```
# 완전검색으로 계산할 것
# k번 만큼 바꾼 횟수의 모든 값을 출력하면 된다 -> 바꾸기 횟수가 10번이 되면 9!이 되므로 시간오버
# memoization - 나왔는지 안 나온 숫자인지 모르므로 테이블에 만들어서 넣을 것

from time import strftime
start_time = time.time()

import sys
sys.stdin = open("(1244)최대상금_input.txt", "r")
T = int(input())
MAXSIZE = 720
N = 10

def Swap(prize, i, j):
    # i to a - integer를 array로 나누기 -> 일의 자리부터 채우기  
    numArr = [0] * numOfcard
    for k in range(numOfcard-1, -1, -1):
        numArr[k] = prize % 10
        prize //= 10
    numArr[i], numArr[j] = numArr[j], numArr[i]

    # a to i - 이번에는 전체 숫자 구하기
    prize = 0
    for k in range(numOfcard):
        prize = prize * 10 + numArr[k]

    return prize


def findMax(prize, num, k):

global ans
    
    for i in range(MAXSIZE):  # 가지치기 - 6!의 크기
        if memo[k][i] == 0:
            memo[k][i] = prize
            break
        elif memo[num][i] == prize:
            return

    if k == num:
        if prize > ans: ans = prize
    else: 
        for i in range(numOfcard-1):   # 바꾸기
            for j in range(i+1, numOfcard):
                findMax(Swap(prize, i, j), num, k+1)


for tc in range(T):
    memo = [[0] * MAXSIZE for _ in range(N+1)]
    prize, num = map(int, input().split())      # 숫자판, 교환횟수
    numOfcard = 0                               # 숫자판의 숫자수
    ans = 0
    t = prize
    while(t):
        t //=10
        numOfcard += 1

    #### Greedy ####    # 6번을 바꾸면 같은 숫자로 되돌아온다
    # if num >= 6 :
    #     if num % 2 == 0 : num = 6    # 완전검색 시 조금 더 줄어준다
    #     else: num = 5

    findMax(prize, num, 0)

    print("#{} {}".format(tc+1, ans))

print(time.time() - start_time, 'seconds')
```





### 2. 그래프

- 상호배타 집합의 자료구조, MST(최소 신장 트리) 만들기

* prim 알고리즘과 kruskal 알고리즘

* cycle이 생기면 그래프가 될 수 없다 -> 그래프인지 아닌지 확인하기 위해 kruskal 알고리즘 사용

* 두 정점 사이의 최단 거리 이용하기



그래프 안에서 최단 거리를 이용한다 - 정점과 간선들의 집합으로 구성된 자료



* 그래프 유형 : 무향 그래프(방향성 없음, 인접행렬로 두 번 표시), 유향 그래프(인접행렬로 한 번), 가중치 그래프, 사이클 없는 방향 그래프, 완전 그래프, 부분 그래프

```
(V * (V-1)) / 2
```



* 인접 : 두 개의 정점에 간선이 연결된 경우 - 완전 그래프에 속한 임의의 두 정점은 모두 인접해 있다

* 경로 : 간선들을 순서대로 나열한 것이다



* 인접행렬

정방 행렬 - 행 번호와 열 번호는 그래프의 정점에 대응한다(연결되었다면 1, 그렇지 않으면 0)

가중치가 있으면 1 대신 숫자를 사용한다, 방향성 고려

진입차수(들어오는 경우)는 열, 진출차수(나가는 경우)는 행에 넣는다

단점 : 0이 너무 많아 메모리를 낭비한다



* 인접리스트

각 정점에 대한 정점들을 순차적으로 표현한다

```
0 | 6 5 1 2   -> 0에서 1, 2, 5, 6에 연결되었다고 인식

배열로 표현하면 0을 세로에 넣는다 -> 6 5 1 2
딕셔너리를 쓰면 배열보다 느리다
```



* 친구 관계 문제

```
# A에서 시작해 한 명의친구에게만 소속을 전달할 수 있다면, 몇 명의 친구가 소식을 전달받을 수 있는가?

# 간선으로 정보가 들어온다
# 가장 늦게 전달받는 사람은 누구인가? - BFS
```



* 그래프 탐색 : 비선형 구조인 그래프의 모든 정점을 빠짐없이 탐색하는 방법



(1) DFS - 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색하다 더 이상 갈 곳이 없으면 최근의 갈림길까지 되돌아오고, 다른 방향의 정점으로 탐색을 반복하는 방식 = 스택 사용

```
stack.append()  # 마지막에 넣어짐
stack.pop()  # 기본적으로 -1
len(stack) == 0  # stack에 아무 것도 없다
```



(2) BFS - 탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식 = 큐 사용

```
queue.append()
queue.pop(0)
len(queue) == 0
```



```
BFS에서 거리를 계산하려면 가장 마지막에 t+1을 사용해서 넣는다
```



* 서로소 집합들 - 교집합이 없는 경우

집합에 속한 하나의 특정 멤버를 통해 각 집합들을 구분한다 = 대표자

make-set(x) / find-set(x) / union(x, y) -> x, y가 대표자이다

union(x, y) -> x가 전체 집합의 대표가 된다

Find-set(y) -> y집합의 대표자를 찾는 메소드(union되었다면 전체 집합의 대표자가 나온다)



같은 집합 원소들을 하나의 연결리스트로 관리한다 -> 같은 집합 안에서 원소들을 find-set을 통해 cycle이 생기는지 생기지 않는지 확인하는 것



* 상호배타 집합을 트리로 표현하기

자식 노드는 부모 노드를 가리키며, 루트 노드는 대표자가 된다



make-set() : 새로운 집합을 생성하는 연산

```
	a  b  c  d  e  f
P   0  1  2  3  4  5   # 인덱스로 표시
```



Union(c, d) & Union(e, f)  -> 각각 c와 e를 대표자로 함

```
	a  b  c  d  e  f
P   0  1  2  2  4  4
```



Union(d, f) -> d가 대표자이므로, c까지 이동한다

```
	a  b  c  d  e  f
P   0  1  2  2  2  4
```



Find-Set(d) -> 자기 자신으로 이동해서 그 번호에 따라 이동한다



```
union(x, y):
	p[Find-set(y)] <- Find-set(x)   # 부모 변경하는 내용

ex)
	p[d(3)] <- c(2)
```



* 연산

Path compression : 같은 결과가 나오는 집합들은 모두 같은 연산으로 묶기(모두 root를 향하기)

Rank Union : 깊이로 합치기(rank가 낮은 집합을 rank가 높은 집합에 붙이기)

결국 위 연산을 표현하려면 p의 값을 바꾸면 된다



```
find_set(x):
	if x != p[x]:
		p[x] = find_set(p[x])   # 부모 정보 갱신 -> 그러나 앞서 짧은 코드로 구현하기
	return p[x]
```





* 최소신장트리

무향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치의 합이 최소인 신장 트리



그림을 통해 가중치를 넣은 인접행렬로 표현한다(X)

부모와 자식 + 가중치를 배열에 넣어서 표현한다



* Prim 알고리즘 = 그리디 방식

하나의 정점에서 연결된 간선 중 하나씩 선택하면서 MST를 만들어 가는 방식(임의 정점을 선택해서 시작, 선택한 정점과 인접하는 정점들 중 최소 비용의 간선이 존재하는 정점을 반복해서 선택함)

서로소인 2개의 집합 정보 유지 : 트리 정점들 + 비트리 정점들



특정한 정점에서 가장 가중치가 낮은 인접 정점을 선택한다

인접 정점과 집합을 만들고, 다른 연결되지 않은 정점들도 집합을 만들어 집합 간의 연결선 중 가장 가중치가 낮은 정점 선택하기

```
def MST_PRIM(G, r):   # G = 그래프, r = 시작 정점
	for u in G.V:
		u.key = 987654321   # key는 무한대로 넣음
		u.p = i   # 자기 자신을 부모라고 넣음
       
    r.key = 0   # 시작 정점의 key는 0으로 바꿈
    Q = G.V   # 큐를 만들어 넣음, 가장 작은 것을 찾아 visited로 처리한다
    
    while Q != 0:
    	u = min(Q)   # 큐에서 가중치가 가장 작은 것을 찾음
    	for v in G.Adj[u]:   # u에서 모든 인접한 정점들 중
    		if visited[v] == 0 and w(u, v) < v.key:  # 방문하지 않고, u-v의 가중치가 v.key(무한대)보다 작은 경우
    			v.p = u   # 그 가중치가 어디에서 왔는가?
    			v.key = w(u, v)   # 가중치를 작은 값으로 바꿈
    			
# 0번부터 시작하면서 가장 짧은 가중치부터 순차적으로 연결해간다(단, 가중치가 낮더라도 연결되지 않았다면 이동 불가)
# 따라서 key와 p 2개를 만들어야 한다
```



* KRUSKAL 알고리즘

모든 간선을 가중치에 따라 오름차순으로 정렬한다 -> 가중치가 가장 낮은 간선부터 선택하면서 트리 증가(사이클이 존재하면 그 다음으로 가중치가 낮은 간선 선택) -> n-1개의 간선이 선택되면 종료



```
def MST-KRUSKAL(G, w):
	A = 0
	for vertex v in G.V:
		make_set(v)
		
	가중치에 따라 정렬  -> 

	for 가중치가 가장 낮은 간선 선택 -> n-1개까지:
		if find_set(u) != find_set(v):
			union(u, v)
	
	return A
	
# 우선 인덱스(정점)와 정점의 부모가 있는 테이블을 만든다
# 출발 정점, 도착 정점, 간선의 가중치를 넣은 배열을 만든다
# 가중치에 따라 정렬한다
# 가중치가 가장 낮은 간선을 선택한다
# u와 v의 대표자가 다르면 출발정점을 대표자에 넣는다
```



* 연습문제 - 최소 신장 트리

```
# MST를 구현하기 위한 2가지 방법 Prim, Kruskal



```



* 최단 경로

간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중 가중치의 합이 최소인 경로 = 가장 빨리 가는 길

하나의 시작 정점에서 끝 정점까지의 최단 경로 : 다익스트라 알고리즘(음의 가중치를 허용하지 않음)

모든 정점들에 대한 최단 경로 : 플로이드-워샬 알고리즘(n^3)



* 다익스트라 알고리즘

**시작 정점**에서 거리가 최소인 정점을 선택하면서 최단 경로를 구하는 방식 = 시작 정점보다 거리가 먼 곳은 계산하지 못 함

시작 정점부터 끝 정점까지의 최단 경로에 정점 x가 존재한다 -> 따라서 s ~ x ~ t의 최단경로를 구한다

그리디 알고리즘으로 프림 알고리즘과 유사하다



```
def dijkstra(s, A, D):
	U = visited[]
	
	for 모든 정점 v:  # 인접한 정점만 계산할 것 -> 연결된 두 정점 사이의 거리는 무한대로 가정
		D[v] = A[s][v]   # 출발점에서 모든 정점까지 갈 수 있는 인접행렬의 값을 가져온다
		
	while U != V:  # 방문하지 않은 정점 중 최소의 가중치 찾기
		# w = 방금 방문한 인접 정점 -> 무한대인 가중치는 못간다
		# 가중치는 출발점부터의 가중치이다 -> a + b + d = 9, a + b + c = 5
		# 계속해서 인접 정점들까지의 가중치를 작은 쪽으로 더해나간다(방문한 곳은 제외)
	
		for w에 인접한 모든 정점 v:
			D[v] = min(D[v], D[w] + A[w][v])
```



* 자기 자신을 제외하고 인접한 모든 정점 사이의 거리는 무한대로 가정한다 -> 출발지의 가중치를 계속 더해나간다
* 경로는 알 수 없고 최종 도착지까지의 거리만 알 수 있다



* 코드 복습

(1) Prim - 출발점은 내 마음대로, 시작 가중치는 0, 중간 경로에 들를 때마다 방금 지나온 곳의 가중치를 넣음

중간 경로는 현재 방문했던 모든 정점에서 이동할 수 있는 간선이 있는 정점들 중 가장 가중치가 작은 곳



(2) 다익스트라 - 출발점에 따라 값이 달라짐, 출발점에서 가장 가중치가 작은 정점으로 이동함, 중간 경로에 들를 때마다 이동한 간선에 있는 모든 가중치를 더함

하나의 정점에서 여러 정점으로 갈 수 있으면 현재 정점에서 가장 가중치가 작은 곳부터 먼저 방문한다

출발점부터 계속 가중치를 더해나간다



(1)의 시간 복잡도는 n^2(정점 개수), (2)의 시간복잡도는 mlogm(간선 정렬하는데 시간)



* 플로이드-워샬 알고리즘(가중치에 음수가 있어도 가능) - APS 파이썬 응용 2 p)233 참고

한 도시에서 다른 도시로 직항로가 없는 경우 가장 빨리 갈 수 있는 항로를 찾는 문제

방향성 그래프에서 최단경로 찾기

DFS로 brute-force를 구현하면 반드시 에러가 난다



모든 쌍 최단 경로를 찾는 동적 계획 알고리즘

플로이드 알고리즘의 시간 복잡도는 n^3이지만, 다익스트라 알고리즘보다 효율적이다

```
def AllPairsShortest(D[][]):
	for k in range(n):  # k가 1부터 n까지 이동(경유점)
		for i in range(n):   # i부터 j로 이동
			for j in range(n):
				D[i][j] = min(D[i][k] + D[k][j], D[i][j])   # k=1을 바탕으로 k=2 이상을 구함
```



위 식은 점화식과 비슷하다 -> 두 점을 직접 가는 방법과 돌아가는 방법을 고려하자.

즉 점1에서 시작해 점1, 2 -> 점1, 2, 3과 같이 모든 점을 경유 가능한지 고려하면서 모든 쌍의 최단 경로의 거리를 계산한다



```
Dij[k]   -> i부터 j까지 가되, k를 경유할지 말지 결정
Dij0  = 선분의 가중치(경유점 없이 바로 가는 것)
Dij1 = i부터 j까지 가는 경로 중 경유점 1개를 포함한 것과 직접 가는 거리 중 짧은 거리 비교
Dij2 = i부터 j까지 가는 경로 중 경유점 2개를 포함한 것과 위 거리 중 짧은 거리 비교
-> Dij1을 미리 계산해 놓아야 한다(경유점 1개를 포함해 가는 거리)

Dijk = k개를 경유해 i-j를 가는 방법 -> k-1개를 경유하는 방법 등 모든 거리를 구해야 한다
```



따라서 가중치를 포함한 이차원 배열(연결선이 없으면 무한대로 표시)

-> 무한대에 있는 칸의 값을 최소값으로 바꾸거나 기존에 존재하는 값들을 더 짧게 바꾸는 방식



















